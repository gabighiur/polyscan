{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { TagsWithInnerContent, computeHashes, hashTag, HasElementTags, tagDedupeKey, defineHeadPlugin } from '@unhead/shared';\nfunction setAttrs(ctx, newEntry = false, markSideEffect) {\n  const {\n    tag,\n    $el\n  } = ctx;\n  if (!$el) return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value) return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect) markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c)) $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\")) markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if (newEntry || $el.getAttribute(k) !== value) $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag)) {\n    if (tag.textContent && tag.textContent !== $el.textContent) $el.textContent = tag.textContent;else if (tag.innerHTML && tag.innerHTML !== $el.innerHTML) $el.innerHTML = tag.innerHTML;\n  }\n}\nlet prevHash = false;\nasync function renderDOMHead(head, options = {}) {\n  const beforeRenderCtx = {\n    shouldRender: true\n  };\n  await head.hooks.callHook(\"dom:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender) return;\n  const dom = options.document || head.resolvedOptions.document || window.document;\n  const tagContexts = (await head.resolveTags()).map(setupTagRenderCtx);\n  if (head.resolvedOptions.experimentalHashHydration) {\n    prevHash = prevHash || head._hash || false;\n    if (prevHash) {\n      const hash = computeHashes(tagContexts.map(ctx => ctx.tag._h));\n      if (prevHash === hash) return;\n      prevHash = hash;\n    }\n  }\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map(entry => entry._sde).forEach(sde => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const markSideEffect = (ctx, key, fn) => {\n    key = `${ctx.renderId}:${key}`;\n    if (ctx.entry) ctx.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  function setupTagRenderCtx(tag) {\n    const entry = head.headEntries().find(e => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashTag(tag),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      markSideEffect: (key, fn) => markSideEffect(renderCtx, key, fn)\n    };\n    return renderCtx;\n  }\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markEl = ctx => {\n    head._elMap[ctx.renderId] = ctx.$el;\n    renders.push(ctx);\n    markSideEffect(ctx, \"el\", () => {\n      ctx.$el?.remove();\n      delete head._elMap[ctx.renderId];\n    });\n  };\n  for (const ctx of tagContexts) {\n    await head.hooks.callHook(\"dom:beforeRenderTag\", ctx);\n    if (!ctx.shouldRender) continue;\n    const {\n      tag\n    } = ctx;\n    if (tag.tag === \"title\") {\n      dom.title = tag.textContent || \"\";\n      renders.push(ctx);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx, false, markSideEffect);\n      renders.push(ctx);\n      continue;\n    }\n    ctx.$el = head._elMap[ctx.renderId];\n    if (!ctx.$el && tag.key) ctx.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._h}]`);\n    if (ctx.$el) {\n      if (ctx.tag._d) setAttrs(ctx);\n      markEl(ctx);\n      continue;\n    }\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx);\n  }\n  const fragments = {\n    bodyClose: void 0,\n    bodyOpen: void 0,\n    head: void 0\n  };\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length) return;\n    const children = dom?.[pos]?.children;\n    if (!children) return;\n    for (const $el of [...children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags.includes(elTag)) continue;\n      const props = $el.getAttributeNames().reduce((props2, name) => ({\n        ...props2,\n        [name]: $el.getAttribute(name)\n      }), {});\n      const tmpTag = {\n        tag: elTag,\n        props\n      };\n      if ($el.innerHTML) tmpTag.innerHTML = $el.innerHTML;\n      const tmpRenderId = hashTag(tmpTag);\n      let matchIdx = queue.findIndex(ctx => ctx?.renderId === tmpRenderId);\n      if (matchIdx === -1) {\n        const tmpDedupeKey = tagDedupeKey(tmpTag);\n        matchIdx = queue.findIndex(ctx => ctx?.tag._d && ctx.tag._d === tmpDedupeKey);\n      }\n      if (matchIdx !== -1) {\n        const ctx = queue[matchIdx];\n        ctx.$el = $el;\n        setAttrs(ctx);\n        markEl(ctx);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach(ctx => {\n      const pos2 = ctx.tag.tagPosition || \"head\";\n      fragments[pos2] = fragments[pos2] || dom.createDocumentFragment();\n      if (!ctx.$el) {\n        ctx.$el = dom.createElement(ctx.tag.tag);\n        setAttrs(ctx, true);\n      }\n      fragments[pos2].appendChild(ctx.$el);\n      markEl(ctx);\n    });\n  });\n  if (fragments.head) dom.head.appendChild(fragments.head);\n  if (fragments.bodyOpen) dom.body.insertBefore(fragments.bodyOpen, dom.body.firstChild);\n  if (fragments.bodyClose) dom.body.appendChild(fragments.bodyClose);\n  for (const ctx of renders) await head.hooks.callHook(\"dom:renderTag\", ctx);\n  Object.values(staleSideEffects).forEach(fn => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || (fn => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise(resolve => delayFn(() => resolve(doDomUpdate())));\n}\nfunction PatchDomOnEntryUpdatesPlugin(options) {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function (head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\") return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\") delayFn = requestAnimationFrame;\n        debouncedRenderDOMHead(head, {\n          document: options?.document || window.document,\n          delayFn\n        });\n      }\n    }\n  });\n}\nfunction maybeGetSSRHash(document) {\n  return document?.head.querySelector('meta[name=\"unhead:ssr\"]')?.getAttribute(\"content\") || false;\n}\nexport { PatchDomOnEntryUpdatesPlugin, debouncedRenderDOMHead, domUpdatePromise, maybeGetSSRHash, renderDOMHead, setAttrs };","map":{"version":3,"names":["TagsWithInnerContent","computeHashes","hashTag","HasElementTags","tagDedupeKey","defineHeadPlugin","setAttrs","ctx","newEntry","markSideEffect","tag","$el","Object","entries","props","forEach","k","value","String","attrSdeKey","c","split","classSdeKey","classList","remove","contains","add","startsWith","removeAttribute","getAttribute","setAttribute","includes","textContent","innerHTML","prevHash","renderDOMHead","head","options","beforeRenderCtx","shouldRender","hooks","callHook","dom","document","resolvedOptions","window","tagContexts","resolveTags","map","setupTagRenderCtx","experimentalHashHydration","_hash","hash","_h","staleSideEffects","_popSideEffectQueue","headEntries","entry","_sde","sde","key","fn","renderId","find","e","_i","_e","renderCtx","_d","renders","pendingRenders","body","markEl","_elMap","push","title","querySelector","tagPosition","fragments","bodyClose","bodyOpen","pos","queue","length","children","reverse","elTag","tagName","toLowerCase","getAttributeNames","reduce","props2","name","tmpTag","tmpRenderId","matchIdx","findIndex","tmpDedupeKey","pos2","createDocumentFragment","createElement","appendChild","insertBefore","firstChild","values","domUpdatePromise","debouncedRenderDOMHead","doDomUpdate","delayFn","setTimeout","Promise","resolve","PatchDomOnEntryUpdatesPlugin","entries:updated","requestAnimationFrame","maybeGetSSRHash"],"sources":["C:/D/Vue/polyscan/node_modules/@unhead/dom/dist/index.mjs"],"sourcesContent":["import { TagsWithInnerContent, computeHashes, hashTag, HasElementTags, tagDedupeKey, defineHeadPlugin } from '@unhead/shared';\n\nfunction setAttrs(ctx, newEntry = false, markSideEffect) {\n  const { tag, $el } = ctx;\n  if (!$el)\n    return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value)\n        return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect)\n          markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c))\n          $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\"))\n      markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if (newEntry || $el.getAttribute(k) !== value)\n      $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag)) {\n    if (tag.textContent && tag.textContent !== $el.textContent)\n      $el.textContent = tag.textContent;\n    else if (tag.innerHTML && tag.innerHTML !== $el.innerHTML)\n      $el.innerHTML = tag.innerHTML;\n  }\n}\n\nlet prevHash = false;\nasync function renderDOMHead(head, options = {}) {\n  const beforeRenderCtx = { shouldRender: true };\n  await head.hooks.callHook(\"dom:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender)\n    return;\n  const dom = options.document || head.resolvedOptions.document || window.document;\n  const tagContexts = (await head.resolveTags()).map(setupTagRenderCtx);\n  if (head.resolvedOptions.experimentalHashHydration) {\n    prevHash = prevHash || head._hash || false;\n    if (prevHash) {\n      const hash = computeHashes(tagContexts.map((ctx) => ctx.tag._h));\n      if (prevHash === hash)\n        return;\n      prevHash = hash;\n    }\n  }\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map((entry) => entry._sde).forEach((sde) => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const markSideEffect = (ctx, key, fn) => {\n    key = `${ctx.renderId}:${key}`;\n    if (ctx.entry)\n      ctx.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  function setupTagRenderCtx(tag) {\n    const entry = head.headEntries().find((e) => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashTag(tag),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      markSideEffect: (key, fn) => markSideEffect(renderCtx, key, fn)\n    };\n    return renderCtx;\n  }\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markEl = (ctx) => {\n    head._elMap[ctx.renderId] = ctx.$el;\n    renders.push(ctx);\n    markSideEffect(ctx, \"el\", () => {\n      ctx.$el?.remove();\n      delete head._elMap[ctx.renderId];\n    });\n  };\n  for (const ctx of tagContexts) {\n    await head.hooks.callHook(\"dom:beforeRenderTag\", ctx);\n    if (!ctx.shouldRender)\n      continue;\n    const { tag } = ctx;\n    if (tag.tag === \"title\") {\n      dom.title = tag.textContent || \"\";\n      renders.push(ctx);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx, false, markSideEffect);\n      renders.push(ctx);\n      continue;\n    }\n    ctx.$el = head._elMap[ctx.renderId];\n    if (!ctx.$el && tag.key)\n      ctx.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._h}]`);\n    if (ctx.$el) {\n      if (ctx.tag._d)\n        setAttrs(ctx);\n      markEl(ctx);\n      continue;\n    }\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx);\n  }\n  const fragments = {\n    bodyClose: void 0,\n    bodyOpen: void 0,\n    head: void 0\n  };\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length)\n      return;\n    const children = dom?.[pos]?.children;\n    if (!children)\n      return;\n    for (const $el of [...children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags.includes(elTag))\n        continue;\n      const props = $el.getAttributeNames().reduce((props2, name) => ({ ...props2, [name]: $el.getAttribute(name) }), {});\n      const tmpTag = { tag: elTag, props };\n      if ($el.innerHTML)\n        tmpTag.innerHTML = $el.innerHTML;\n      const tmpRenderId = hashTag(tmpTag);\n      let matchIdx = queue.findIndex((ctx) => ctx?.renderId === tmpRenderId);\n      if (matchIdx === -1) {\n        const tmpDedupeKey = tagDedupeKey(tmpTag);\n        matchIdx = queue.findIndex((ctx) => ctx?.tag._d && ctx.tag._d === tmpDedupeKey);\n      }\n      if (matchIdx !== -1) {\n        const ctx = queue[matchIdx];\n        ctx.$el = $el;\n        setAttrs(ctx);\n        markEl(ctx);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach((ctx) => {\n      const pos2 = ctx.tag.tagPosition || \"head\";\n      fragments[pos2] = fragments[pos2] || dom.createDocumentFragment();\n      if (!ctx.$el) {\n        ctx.$el = dom.createElement(ctx.tag.tag);\n        setAttrs(ctx, true);\n      }\n      fragments[pos2].appendChild(ctx.$el);\n      markEl(ctx);\n    });\n  });\n  if (fragments.head)\n    dom.head.appendChild(fragments.head);\n  if (fragments.bodyOpen)\n    dom.body.insertBefore(fragments.bodyOpen, dom.body.firstChild);\n  if (fragments.bodyClose)\n    dom.body.appendChild(fragments.bodyClose);\n  for (const ctx of renders)\n    await head.hooks.callHook(\"dom:renderTag\", ctx);\n  Object.values(staleSideEffects).forEach((fn) => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || ((fn) => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise((resolve) => delayFn(() => resolve(doDomUpdate())));\n}\n\nfunction PatchDomOnEntryUpdatesPlugin(options) {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function(head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\")\n          return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\")\n          delayFn = requestAnimationFrame;\n        debouncedRenderDOMHead(head, { document: options?.document || window.document, delayFn });\n      }\n    }\n  });\n}\n\nfunction maybeGetSSRHash(document) {\n  return document?.head.querySelector('meta[name=\"unhead:ssr\"]')?.getAttribute(\"content\") || false;\n}\n\nexport { PatchDomOnEntryUpdatesPlugin, debouncedRenderDOMHead, domUpdatePromise, maybeGetSSRHash, renderDOMHead, setAttrs };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}